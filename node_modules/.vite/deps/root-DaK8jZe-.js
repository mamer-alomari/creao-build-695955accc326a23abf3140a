//#region node_modules/tiny-invariant/dist/esm/tiny-invariant.js
var isProduction = false;
var prefix = "Invariant failed";
function invariant(condition, message) {
	if (condition) return;
	if (isProduction) throw new Error(prefix);
	var provided = typeof message === "function" ? message() : message;
	var value = provided ? "".concat(prefix, ": ").concat(provided) : prefix;
	throw new Error(value);
}

//#endregion
//#region node_modules/@tanstack/router-core/dist/esm/utils.js
function last(arr) {
	return arr[arr.length - 1];
}
function isFunction(d) {
	return typeof d === "function";
}
function functionalUpdate(updater, previous) {
	if (isFunction(updater)) return updater(previous);
	return updater;
}
function pick(parent, keys) {
	return keys.reduce((obj, key) => {
		obj[key] = parent[key];
		return obj;
	}, {});
}
function replaceEqualDeep(prev, _next) {
	if (prev === _next) return prev;
	const next = _next;
	const array = isPlainArray(prev) && isPlainArray(next);
	if (array || isPlainObject(prev) && isPlainObject(next)) {
		const prevItems = array ? prev : Object.keys(prev);
		const prevSize = prevItems.length;
		const nextItems = array ? next : Object.keys(next);
		const nextSize = nextItems.length;
		const copy = array ? [] : {};
		let equalItems = 0;
		for (let i = 0; i < nextSize; i++) {
			const key = array ? i : nextItems[i];
			if ((!array && prevItems.includes(key) || array) && prev[key] === void 0 && next[key] === void 0) {
				copy[key] = void 0;
				equalItems++;
			} else {
				copy[key] = replaceEqualDeep(prev[key], next[key]);
				if (copy[key] === prev[key] && prev[key] !== void 0) equalItems++;
			}
		}
		return prevSize === nextSize && equalItems === prevSize ? prev : copy;
	}
	return next;
}
function isPlainObject(o) {
	if (!hasObjectPrototype(o)) return false;
	const ctor = o.constructor;
	if (typeof ctor === "undefined") return true;
	const prot = ctor.prototype;
	if (!hasObjectPrototype(prot)) return false;
	if (!prot.hasOwnProperty("isPrototypeOf")) return false;
	return true;
}
function hasObjectPrototype(o) {
	return Object.prototype.toString.call(o) === "[object Object]";
}
function isPlainArray(value) {
	return Array.isArray(value) && value.length === Object.keys(value).length;
}
function getObjectKeys(obj, ignoreUndefined) {
	let keys = Object.keys(obj);
	if (ignoreUndefined) keys = keys.filter((key) => obj[key] !== void 0);
	return keys;
}
function deepEqual(a, b, opts) {
	if (a === b) return true;
	if (typeof a !== typeof b) return false;
	if (isPlainObject(a) && isPlainObject(b)) {
		const ignoreUndefined = (opts == null ? void 0 : opts.ignoreUndefined) ?? true;
		const aKeys = getObjectKeys(a, ignoreUndefined);
		const bKeys = getObjectKeys(b, ignoreUndefined);
		if (!(opts == null ? void 0 : opts.partial) && aKeys.length !== bKeys.length) return false;
		return bKeys.every((key) => deepEqual(a[key], b[key], opts));
	}
	if (Array.isArray(a) && Array.isArray(b)) {
		if (a.length !== b.length) return false;
		return !a.some((item, index) => !deepEqual(item, b[index], opts));
	}
	return false;
}
function createControlledPromise(onResolve) {
	let resolveLoadPromise;
	let rejectLoadPromise;
	const controlledPromise = new Promise((resolve, reject) => {
		resolveLoadPromise = resolve;
		rejectLoadPromise = reject;
	});
	controlledPromise.status = "pending";
	controlledPromise.resolve = (value) => {
		controlledPromise.status = "resolved";
		controlledPromise.value = value;
		resolveLoadPromise(value);
		onResolve?.(value);
	};
	controlledPromise.reject = (e) => {
		controlledPromise.status = "rejected";
		rejectLoadPromise(e);
	};
	return controlledPromise;
}
function escapeJSON(jsonString) {
	return jsonString.replace(/\\/g, "\\\\").replace(/'/g, "\\'").replace(/"/g, "\\\"");
}
function shallow(objA, objB) {
	if (Object.is(objA, objB)) return true;
	if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) return false;
	const keysA = Object.keys(objA);
	if (keysA.length !== Object.keys(objB).length) return false;
	for (const item of keysA) if (!Object.prototype.hasOwnProperty.call(objB, item) || !Object.is(objA[item], objB[item])) return false;
	return true;
}
function hasUriEncodedChars(inputString) {
	return /%[0-9A-Fa-f]{2}/.test(inputString);
}

//#endregion
//#region node_modules/@tanstack/router-core/dist/esm/path.js
function joinPaths(paths) {
	return cleanPath(paths.filter((val) => {
		return val !== void 0;
	}).join("/"));
}
function cleanPath(path) {
	return path.replace(/\/{2,}/g, "/");
}
function trimPathLeft(path) {
	return path === "/" ? path : path.replace(/^\/{1,}/, "");
}
function trimPathRight(path) {
	return path === "/" ? path : path.replace(/\/{1,}$/, "");
}
function trimPath(path) {
	return trimPathRight(trimPathLeft(path));
}
function removeTrailingSlash(value, basepath) {
	if ((value == null ? void 0 : value.endsWith("/")) && value !== "/" && value !== `${basepath}/`) return value.slice(0, -1);
	return value;
}
function exactPathTest(pathName1, pathName2, basepath) {
	return removeTrailingSlash(pathName1, basepath) === removeTrailingSlash(pathName2, basepath);
}
function resolvePath({ basepath, base, to, trailingSlash = "never", caseSensitive }) {
	var _a, _b;
	base = removeBasepath(basepath, base, caseSensitive);
	to = removeBasepath(basepath, to, caseSensitive);
	let baseSegments = parsePathname(base);
	const toSegments = parsePathname(to);
	if (baseSegments.length > 1 && ((_a = last(baseSegments)) == null ? void 0 : _a.value) === "/") baseSegments.pop();
	toSegments.forEach((toSegment, index) => {
		if (toSegment.value === "/") {
			if (!index) baseSegments = [toSegment];
			else if (index === toSegments.length - 1) baseSegments.push(toSegment);
		} else if (toSegment.value === "..") baseSegments.pop();
		else if (toSegment.value === ".");
		else baseSegments.push(toSegment);
	});
	if (baseSegments.length > 1) {
		if (((_b = last(baseSegments)) == null ? void 0 : _b.value) === "/") {
			if (trailingSlash === "never") baseSegments.pop();
		} else if (trailingSlash === "always") baseSegments.push({
			type: "pathname",
			value: "/"
		});
	}
	return cleanPath(joinPaths([basepath, ...baseSegments.map((d) => d.value)]));
}
function parsePathname(pathname) {
	if (!pathname) return [];
	pathname = cleanPath(pathname);
	const segments = [];
	if (pathname.slice(0, 1) === "/") {
		pathname = pathname.substring(1);
		segments.push({
			type: "pathname",
			value: "/"
		});
	}
	if (!pathname) return segments;
	const split = pathname.split("/").filter(Boolean);
	segments.push(...split.map((part) => {
		if (part === "$" || part === "*") return {
			type: "wildcard",
			value: part
		};
		if (part.charAt(0) === "$") return {
			type: "param",
			value: part
		};
		return {
			type: "pathname",
			value: part.includes("%25") ? part.split("%25").map((segment) => decodeURI(segment)).join("%25") : decodeURI(part)
		};
	}));
	if (pathname.slice(-1) === "/") {
		pathname = pathname.substring(1);
		segments.push({
			type: "pathname",
			value: "/"
		});
	}
	return segments;
}
function interpolatePath({ path, params, leaveWildcards, leaveParams, decodeCharMap }) {
	const interpolatedPathSegments = parsePathname(path);
	function encodeParam(key) {
		const value = params[key];
		const isValueString = typeof value === "string";
		if (["*", "_splat"].includes(key)) return isValueString ? encodeURI(value) : value;
		else return isValueString ? encodePathParam(value, decodeCharMap) : value;
	}
	let isMissingParams = false;
	const usedParams = {};
	return {
		usedParams,
		interpolatedPath: joinPaths(interpolatedPathSegments.map((segment) => {
			if (segment.type === "wildcard") {
				usedParams._splat = params._splat;
				const value = encodeParam("_splat");
				if (leaveWildcards) return `${segment.value}${value ?? ""}`;
				return value;
			}
			if (segment.type === "param") {
				const key = segment.value.substring(1);
				if (!isMissingParams && !(key in params)) isMissingParams = true;
				usedParams[key] = params[key];
				if (leaveParams) {
					const value = encodeParam(segment.value);
					return `${segment.value}${value ?? ""}`;
				}
				return encodeParam(key) ?? "undefined";
			}
			return segment.value;
		})),
		isMissingParams
	};
}
function encodePathParam(value, decodeCharMap) {
	let encoded = encodeURIComponent(value);
	if (decodeCharMap) for (const [encodedChar, char] of decodeCharMap) encoded = encoded.replaceAll(encodedChar, char);
	return encoded;
}
function matchPathname(basepath, currentPathname, matchLocation) {
	const pathParams = matchByPath(basepath, currentPathname, matchLocation);
	if (matchLocation.to && !pathParams) return;
	return pathParams ?? {};
}
function removeBasepath(basepath, pathname, caseSensitive = false) {
	const normalizedBasepath = caseSensitive ? basepath : basepath.toLowerCase();
	const normalizedPathname = caseSensitive ? pathname : pathname.toLowerCase();
	switch (true) {
		case normalizedBasepath === "/": return pathname;
		case normalizedPathname === normalizedBasepath: return "";
		case pathname.length < basepath.length: return pathname;
		case normalizedPathname[normalizedBasepath.length] !== "/": return pathname;
		case normalizedPathname.startsWith(normalizedBasepath): return pathname.slice(basepath.length);
		default: return pathname;
	}
}
function matchByPath(basepath, from, matchLocation) {
	if (basepath !== "/" && !from.startsWith(basepath)) return;
	from = removeBasepath(basepath, from, matchLocation.caseSensitive);
	const to = removeBasepath(basepath, `${matchLocation.to ?? "$"}`, matchLocation.caseSensitive);
	const baseSegments = parsePathname(from);
	const routeSegments = parsePathname(to);
	if (!from.startsWith("/")) baseSegments.unshift({
		type: "pathname",
		value: "/"
	});
	if (!to.startsWith("/")) routeSegments.unshift({
		type: "pathname",
		value: "/"
	});
	const params = {};
	return (() => {
		for (let i = 0; i < Math.max(baseSegments.length, routeSegments.length); i++) {
			const baseSegment = baseSegments[i];
			const routeSegment = routeSegments[i];
			const isLastBaseSegment = i >= baseSegments.length - 1;
			const isLastRouteSegment = i >= routeSegments.length - 1;
			if (routeSegment) {
				if (routeSegment.type === "wildcard") {
					const _splat = decodeURI(joinPaths(baseSegments.slice(i).map((d) => d.value)));
					params["*"] = _splat;
					params["_splat"] = _splat;
					return true;
				}
				if (routeSegment.type === "pathname") {
					if (routeSegment.value === "/" && !(baseSegment == null ? void 0 : baseSegment.value)) return true;
					if (baseSegment) {
						if (matchLocation.caseSensitive) {
							if (routeSegment.value !== baseSegment.value) return false;
						} else if (routeSegment.value.toLowerCase() !== baseSegment.value.toLowerCase()) return false;
					}
				}
				if (!baseSegment) return false;
				if (routeSegment.type === "param") {
					if (baseSegment.value === "/") return false;
					if (baseSegment.value.charAt(0) !== "$") params[routeSegment.value.substring(1)] = decodeURIComponent(baseSegment.value);
				}
			}
			if (!isLastBaseSegment && isLastRouteSegment) {
				params["**"] = joinPaths(baseSegments.slice(i + 1).map((d) => d.value));
				return !!matchLocation.fuzzy && (routeSegment == null ? void 0 : routeSegment.value) !== "/";
			}
		}
		return true;
	})() ? params : void 0;
}

//#endregion
//#region node_modules/@tanstack/router-core/dist/esm/root.js
var rootRouteId = "__root__";

//#endregion
export { pick as C, invariant as E, last as S, shallow as T, escapeJSON as _, joinPaths as a, isPlainArray as b, parsePathname as c, resolvePath as d, trimPath as f, deepEqual as g, createControlledPromise as h, interpolatePath as i, removeBasepath as l, trimPathRight as m, cleanPath as n, matchByPath as o, trimPathLeft as p, exactPathTest as r, matchPathname as s, rootRouteId as t, removeTrailingSlash as u, functionalUpdate as v, replaceEqualDeep as w, isPlainObject as x, hasUriEncodedChars as y };
//# sourceMappingURL=root-DaK8jZe-.js.map