{"version":3,"file":"index.mjs","sources":["../src/index.ts"],"sourcesContent":["import {\n  type InfiniteData,\n  type QueryClient,\n  type QueryFunctionContext,\n  type SkipToken,\n  type UseInfiniteQueryOptions,\n  type UseInfiniteQueryResult,\n  type UseMutationOptions,\n  type UseMutationResult,\n  type UseQueryOptions,\n  type UseQueryResult,\n  type UseSuspenseQueryOptions,\n  type UseSuspenseQueryResult,\n  useInfiniteQuery,\n  useMutation,\n  useQuery,\n  useSuspenseQuery,\n} from \"@tanstack/react-query\";\nimport type {\n  ClientMethod,\n  DefaultParamsOption,\n  Client as FetchClient,\n  FetchResponse,\n  MaybeOptionalInit,\n} from \"openapi-fetch\";\nimport type { HttpMethod, MediaType, PathsWithMethod, RequiredKeysOf } from \"openapi-typescript-helpers\";\n\n// Helper type to dynamically infer the type from the `select` property\ntype InferSelectReturnType<TData, TSelect> = TSelect extends (data: TData) => infer R ? R : TData;\n\ntype InitWithUnknowns<Init> = Init & { [key: string]: unknown };\n\nexport type QueryKey<\n  Paths extends Record<string, Record<HttpMethod, {}>>,\n  Method extends HttpMethod,\n  Path extends PathsWithMethod<Paths, Method>,\n  Init = MaybeOptionalInit<Paths[Path], Method>,\n> = Init extends undefined ? readonly [Method, Path] : readonly [Method, Path, Init];\n\nexport type QueryOptionsFunction<Paths extends Record<string, Record<HttpMethod, {}>>, Media extends MediaType> = <\n  Method extends HttpMethod,\n  Path extends PathsWithMethod<Paths, Method>,\n  Init extends MaybeOptionalInit<Paths[Path], Method>,\n  Response extends Required<FetchResponse<Paths[Path][Method], Init, Media>>, // note: Required is used to avoid repeating NonNullable in UseQuery types\n  Options extends Omit<\n    UseQueryOptions<\n      Response[\"data\"],\n      Response[\"error\"],\n      InferSelectReturnType<Response[\"data\"], Options[\"select\"]>,\n      QueryKey<Paths, Method, Path>\n    >,\n    \"queryKey\" | \"queryFn\"\n  >,\n>(\n  method: Method,\n  path: Path,\n  ...[init, options]: RequiredKeysOf<Init> extends never\n    ? [InitWithUnknowns<Init>?, Options?]\n    : [InitWithUnknowns<Init>, Options?]\n) => NoInfer<\n  Omit<\n    UseQueryOptions<\n      Response[\"data\"],\n      Response[\"error\"],\n      InferSelectReturnType<Response[\"data\"], Options[\"select\"]>,\n      QueryKey<Paths, Method, Path>\n    >,\n    \"queryFn\"\n  > & {\n    queryFn: Exclude<\n      UseQueryOptions<\n        Response[\"data\"],\n        Response[\"error\"],\n        InferSelectReturnType<Response[\"data\"], Options[\"select\"]>,\n        QueryKey<Paths, Method, Path>\n      >[\"queryFn\"],\n      SkipToken | undefined\n    >;\n  }\n>;\n\nexport type UseQueryMethod<Paths extends Record<string, Record<HttpMethod, {}>>, Media extends MediaType> = <\n  Method extends HttpMethod,\n  Path extends PathsWithMethod<Paths, Method>,\n  Init extends MaybeOptionalInit<Paths[Path], Method>,\n  Response extends Required<FetchResponse<Paths[Path][Method], Init, Media>>, // note: Required is used to avoid repeating NonNullable in UseQuery types\n  Options extends Omit<\n    UseQueryOptions<\n      Response[\"data\"],\n      Response[\"error\"],\n      InferSelectReturnType<Response[\"data\"], Options[\"select\"]>,\n      QueryKey<Paths, Method, Path>\n    >,\n    \"queryKey\" | \"queryFn\"\n  >,\n>(\n  method: Method,\n  url: Path,\n  ...[init, options, queryClient]: RequiredKeysOf<Init> extends never\n    ? [InitWithUnknowns<Init>?, Options?, QueryClient?]\n    : [InitWithUnknowns<Init>, Options?, QueryClient?]\n) => UseQueryResult<InferSelectReturnType<Response[\"data\"], Options[\"select\"]>, Response[\"error\"]>;\n\nexport type UseInfiniteQueryMethod<Paths extends Record<string, Record<HttpMethod, {}>>, Media extends MediaType> = <\n  Method extends HttpMethod,\n  Path extends PathsWithMethod<Paths, Method>,\n  Init extends MaybeOptionalInit<Paths[Path], Method>,\n  Response extends Required<FetchResponse<Paths[Path][Method], Init, Media>>,\n  Options extends Omit<\n    UseInfiniteQueryOptions<\n      Response[\"data\"],\n      Response[\"error\"],\n      InferSelectReturnType<InfiniteData<Response[\"data\"]>, Options[\"select\"]>,\n      QueryKey<Paths, Method, Path>,\n      unknown\n    >,\n    \"queryKey\" | \"queryFn\"\n  > & {\n    pageParamName?: string;\n  },\n>(\n  method: Method,\n  url: Path,\n  init: InitWithUnknowns<Init>,\n  options: Options,\n  queryClient?: QueryClient,\n) => UseInfiniteQueryResult<\n  InferSelectReturnType<InfiniteData<Response[\"data\"]>, Options[\"select\"]>,\n  Response[\"error\"]\n>;\n\nexport type UseSuspenseQueryMethod<Paths extends Record<string, Record<HttpMethod, {}>>, Media extends MediaType> = <\n  Method extends HttpMethod,\n  Path extends PathsWithMethod<Paths, Method>,\n  Init extends MaybeOptionalInit<Paths[Path], Method>,\n  Response extends Required<FetchResponse<Paths[Path][Method], Init, Media>>, // note: Required is used to avoid repeating NonNullable in UseQuery types\n  Options extends Omit<\n    UseSuspenseQueryOptions<\n      Response[\"data\"],\n      Response[\"error\"],\n      InferSelectReturnType<Response[\"data\"], Options[\"select\"]>,\n      QueryKey<Paths, Method, Path>\n    >,\n    \"queryKey\" | \"queryFn\"\n  >,\n>(\n  method: Method,\n  url: Path,\n  ...[init, options, queryClient]: RequiredKeysOf<Init> extends never\n    ? [InitWithUnknowns<Init>?, Options?, QueryClient?]\n    : [InitWithUnknowns<Init>, Options?, QueryClient?]\n) => UseSuspenseQueryResult<InferSelectReturnType<Response[\"data\"], Options[\"select\"]>, Response[\"error\"]>;\n\nexport type UseMutationMethod<Paths extends Record<string, Record<HttpMethod, {}>>, Media extends MediaType> = <\n  Method extends HttpMethod,\n  Path extends PathsWithMethod<Paths, Method>,\n  Init extends MaybeOptionalInit<Paths[Path], Method>,\n  Response extends Required<FetchResponse<Paths[Path][Method], Init, Media>>, // note: Required is used to avoid repeating NonNullable in UseQuery types\n  TOnMutateResult = unknown,\n>(\n  method: Method,\n  url: Path,\n  options?: Omit<\n    UseMutationOptions<Response[\"data\"], Response[\"error\"], Init, TOnMutateResult>,\n    \"mutationKey\" | \"mutationFn\"\n  >,\n  queryClient?: QueryClient,\n) => UseMutationResult<Response[\"data\"], Response[\"error\"], Init, TOnMutateResult>;\n\nexport interface OpenapiQueryClient<Paths extends {}, Media extends MediaType = MediaType> {\n  queryOptions: QueryOptionsFunction<Paths, Media>;\n  useQuery: UseQueryMethod<Paths, Media>;\n  useSuspenseQuery: UseSuspenseQueryMethod<Paths, Media>;\n  useInfiniteQuery: UseInfiniteQueryMethod<Paths, Media>;\n  useMutation: UseMutationMethod<Paths, Media>;\n}\n\nexport type MethodResponse<\n  CreatedClient extends OpenapiQueryClient<any, any>,\n  Method extends HttpMethod,\n  Path extends CreatedClient extends OpenapiQueryClient<infer Paths, infer _Media>\n    ? PathsWithMethod<Paths, Method>\n    : never,\n  Options = object,\n> =\n  CreatedClient extends OpenapiQueryClient<infer Paths extends { [key: string]: any }, infer Media extends MediaType>\n    ? NonNullable<FetchResponse<Paths[Path][Method], Options, Media>[\"data\"]>\n    : never;\n\n// TODO: Add the ability to bring queryClient as argument\nexport default function createClient<Paths extends {}, Media extends MediaType = MediaType>(\n  client: FetchClient<Paths, Media>,\n): OpenapiQueryClient<Paths, Media> {\n  const queryFn = async <Method extends HttpMethod, Path extends PathsWithMethod<Paths, Method>>({\n    queryKey: [method, path, init],\n    signal,\n  }: QueryFunctionContext<QueryKey<Paths, Method, Path>>) => {\n    const mth = method.toUpperCase() as Uppercase<typeof method>;\n    const fn = client[mth] as ClientMethod<Paths, typeof method, Media>;\n    const { data, error, response } = await fn(path, { signal, ...(init as any) }); // TODO: find a way to avoid as any\n    if (error) {\n      throw error;\n    }\n    if (response.status === 204 || response.headers.get(\"Content-Length\") === \"0\") {\n      return data ?? null;\n    }\n\n    return data;\n  };\n\n  const queryOptions: QueryOptionsFunction<Paths, Media> = (method, path, ...[init, options]) => ({\n    queryKey: (init === undefined ? ([method, path] as const) : ([method, path, init] as const)) as QueryKey<\n      Paths,\n      typeof method,\n      typeof path\n    >,\n    queryFn,\n    ...options,\n  });\n\n  return {\n    queryOptions,\n    useQuery: (method, path, ...[init, options, queryClient]) =>\n      useQuery(queryOptions(method, path, init as InitWithUnknowns<typeof init>, options), queryClient),\n    useSuspenseQuery: (method, path, ...[init, options, queryClient]) =>\n      useSuspenseQuery(queryOptions(method, path, init as InitWithUnknowns<typeof init>, options), queryClient),\n    useInfiniteQuery: (method, path, init, options, queryClient) => {\n      const { pageParamName = \"cursor\", ...restOptions } = options;\n      const { queryKey } = queryOptions(method, path, init);\n      return useInfiniteQuery(\n        {\n          queryKey,\n          queryFn: async ({ queryKey: [method, path, init], pageParam = 0, signal }) => {\n            const mth = method.toUpperCase() as Uppercase<typeof method>;\n            const fn = client[mth] as ClientMethod<Paths, typeof method, Media>;\n            const mergedInit = {\n              ...init,\n              signal,\n              params: {\n                ...(init?.params || {}),\n                query: {\n                  ...(init?.params as { query?: DefaultParamsOption })?.query,\n                  [pageParamName]: pageParam,\n                },\n              },\n            };\n\n            const { data, error } = await fn(path, mergedInit as any);\n            if (error) {\n              throw error;\n            }\n            return data;\n          },\n          ...restOptions,\n        },\n        queryClient,\n      );\n    },\n    useMutation: (method, path, options, queryClient) =>\n      useMutation(\n        {\n          mutationKey: [method, path],\n          mutationFn: async (init) => {\n            const mth = method.toUpperCase() as Uppercase<typeof method>;\n            const fn = client[mth] as ClientMethod<Paths, typeof method, Media>;\n            const { data, error } = await fn(path, init as InitWithUnknowns<typeof init>);\n            if (error) {\n              throw error;\n            }\n\n            return data as Exclude<typeof data, undefined>;\n          },\n          ...options,\n        },\n        queryClient,\n      ),\n  };\n}\n"],"names":["method","path","init"],"mappings":"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"}